# Wall is You - Documentation

> [!Note]
> Я посторался подробно объяснить устройство классов, ключевых методов и функции.
> Если что-то останется непонятным, то вы всегда можете обратиться ко мне лично или через Discord.
> Надеюсь, что у вас не возникнет вопросов. Удачного изучения документации!

> [!Important]
> Оригинальный язык документации русский
> Для перевода на другие языки я использовал Deepl для экономии времени
> Если какие-то фразы окажутся неясными или странными, вы можете обратиться ко мне для разъяснений

## Content

- ### [Hierarchy](#Hierarchy)
- ### [Overview of classes](#Overview-of-classes)
- ### [Entities](#Entities)
- ### [Game field class (Dungeon)](#Game-field-class-(Dungeon))
- ### [Level parser method](#Level-parser-method)
- ### [Game Controller](#Game-Controller)
- ### [Menu (app.py)](#Menu-(app.py))
- ### [Menu View](#Menu-View)
- ### [Game View](#Game-View)


## Hierarchy

- App
	- Menu View
	- Game View
		- Game controller
			- Dungeon
				- Cell

<br>

## Overview of classes

1. Menu View и Game View ответственны за 
-  рендеринг меню и игры
-  обработку событий (нажатия клавиш и клики)

2. Cell - это объект клетки с состояниями стена и методом для ее переворачивания.

3. Dungeon - это объект, состоящий из экземпляров класа Cell. У него имеются методы для поиска соседей и проверки на наличие общих коридоров. По сути он представляет из себя карту уровня.

4. Game controller - это объект хранящий состояния игры и экземпляр Dungeon (карту / матрицу с клетками и их состояниями). Он также может вычислить следующий путь и обработать прохождение пути и встречи с врагами.

## Entities

### Cell

#### Description
Класс Cell представляет из себя из себя клетку, где у каждой стороны есть состояние, отображающие наличие коридора (True - присутствует; False - отсутствует).

#### Attributes
Аттрибуты представляют из себя 4 состояния стены.

#### Methodes
```python
def rotate(self)
```
- метод возвращает экземпляр класса Cell со сдвинутыми по часовой состояниями стены

<br>

```python
def has_dir(self, directory)
```
- метод проверяет наличие коридора в указанном направлении, обращаясь к словарю с состаяниями стены по ключю переданного направления



### Dragon and Hero
Классы Dragon и Hero в качестве аттрибутов имеют позицию и уровень.
> [!IMPORTANT]
>На данном этапе разработки они используются в качестве типов с помощью
декоратора @dataclass.



## Game field class (Dungeon)

### Description
Данный класс представляет из себя матрицу экземпляров Cell

### Attributes
В качестве аттрибутов класс распалагает вышеупомянутой матрицей,
ее вычисляемыми шириной и высотой.

> [!Warning]
> ширина и высота в следующей версии будут присваиваться
> в магическом методе __init__

### Methodes

```python
def in_bound(self, row, column)
```
- метод проверяет не выходят ли координаты за диапозон матрицы

<br>

```python
def get_cell(self, row, column)
```
- метод по координатам возвращает нужный экземпляр,
	если координаты не выходят за рамки матрицы

<br>

```python
def rotate_cell(self, row, column)
```
- метод переварачивает клетку по координатам

```python
def neighbors(neighbors)
```

1. метод проходиться циклом по словарю DIRECTIONS через метод items() со значениями отступов для перемещения на соседнюю клетку по четырем направлениям, чьи названия используются в качестве ключей

2. Координаты соседней клетки = текущие + отступы

3. В случае, если координаты соседней клетки не выходят за границы (метод in_bounds()), то через yield они и их направление возвращаются кортежем.

<br>

```python
def are_connected(
	self,
	row, column,
	n_row, n_column #neighbor cell coordinates
)
```
- **метод проверяет, связаны ли соседние клетки коридорами**

1. сначала мы получаем значения отступов (таких же как в DIRECTIONS)

```python
shifted_row = n_row - row
shifted_col = n_col - col
```

2. далее мы опять тем же методом проходимся по DIRECTIONS
3. каждую итерацию проверяем, не раны ли отступы по рядам и столбцам
	отступам по направлению
4. если равны, то проверяем не выходят ли клетки за рамки
5. получаем по координатам экземпляры Cell и проверяем, есть ли коридоры у противоположных направлении этих клеток.



## Level parser method

```python
def load_levels(path)
```
**метод, который парсит json файлы с уровнями

load_levels парсит "grid", создает матрицу экземпляров Cell, на основе
которой создает экземпляр Dungeon (game field class).

также load_levels создает объекты:
- hero (c уровнем и координатами);
- dragons (лист драконов со свойствами как у героя)

все созданные объекты (включая dungeon) метод возвращает кортежем



## Game Controller

### Description
Данный класс содержит сотстояния игры и entities, а также функционал игры.

### Attributes
- entities: dragons, hero
- game_over: состояние окончании игры
- options: словарь с опциями, выбранными в меню
- game_result: результат игры
- last_path: последний просчитанный путь героя

### Methodes

```python
def _load_level(self)
```
- внутренний метод, задающий начальные состояния и получающий значения entities из одноименного парсера load_levels()

<br>

```python
def reset(self)
```
- метод для сброса состоянии к дефолтным значениям, чтобы начать игры сначала. Для этого метод вызывает _load_level() внутри себя.

<br>

```python
def is_over(self)
```
- **метод передает состояние game_over**

> [!Warning]
> метод **is_over** будет удален в следующей версии
> из-за ненадобности

```python
def rotate_cell(self, row, col)
```
**вызывает метод класса Dungeon rotate_cell()**

<br>

```python
def _compute_intention_path(self, max_steps)
```
- **метод предназначен для выстраивания следующего пути/хода.**

1. сначала создаются переменные с координатами героя из hero["position"];
2. цикл while с прибавлением steps += 1 до max_steps или break;
3. обнуление next_pos;
4. метод проходиться циклом по соседним клеткам, полученным через метод neighbors класса Dungeon;
5. если клетка равна предыдущей (переменная "previous), пропускаем ее
6. через метод are_connected класса Dungeon проверям наличие общих коридоров клеток;
7. если они есть, то присваиваем координаты в next_pos, далее идет break;
8. если после цикла next_pos остается None, то цикл while останавливается и возвращается текущий лист "path";
9. переменной "previous" присваиватся текущие координаты и в "path" добавляется next_pos, к steps добавляется 1 шаг и цикл повторяется пока next_pos не станет None (то есть цткл дойдет до тупика).

<br>

```python
def end_turn(self, render)
```
- **метод проходится по высчитанному пути и обрабатывает случаи встреч с врагами.**

> [!Note]
> в качестве параметра передается метод render класса GameView ответственнго за верстку игровой сессии и обработки нажатии клавищ и кликов.

1. метод высчитывает путь через _compute_intention_path() и получает level героя.
2. далее циклом for он проходится по координатам пути
3. задаются переменные для дракона
4. также циклом for метод проходится по списку драконов и сверяет их координаты с текущими. если они равны, то мы вытаскиваем id дракона и его уровень.
5. если уровень героя равен или выше, то дракон по id удаляется из списка и его уровень отходит герою, иначе игра окончена поражением героя (статус сессии становиться "lose").
6. после окончания сдвига на клетку происходит перерисовка персонажа.
7. после цикла проиходит проверка состояния сессии и количества драконов.если все драконы повержены, то сессии присваивается стату "win"



## Menu (app.py)

app.py - файл, отвечающий за переключение между меню и игровой сессией.

### States/Variables

1. В начале функции main создается окно и задается его расштрение. Также создается объект menu, и создаются переменные под GameController и GameView.


2.  В app.py существует перемменная состоянии игры с одноименным названием state.

#### Обзор состоянии переменной state:

1. ***MENU*** - в этом сосстоянии происходит постоянный рендер меню и обработка нажатии на клавиши и кликов по кнопкам меню.
- Cобытия:
	- **start** (`Enter` или кнопка `Play`): создание экземпляров GameController и GameView + передача данных сессии (выбранных опции) в game controller
	- **quit** (`Esc` или кнопка `Exit`): выход из игры

2. ***Game*** - в этом состоянии проиходит рендер игрового поля и запуск обработчика событий игровой сессии.
- События:
	- **END_TURN** (`Space`): сделать ход
	- **RESTART** (shortcut `R`): начать игру заново
	- **TO_MENU** (`Esc`): назад в меню



## Menu View

### Utils

```python
def list_levels()
```

- функция парсит название файлов c расширением json в директории levels

```python
LEVELS_DIR = _PROJECT_ROOT / "components" / "levels"
```

<br>

```python
def point_in_rect(
	x, y, # координаты по которым пришелся клик
	rectancle # кортеж с координатами и размерами треугольника
)
```

- метод проверяет находиться ли координаты клика в диаозоне rectangle


### Attributes

- levels: список уровней;
- sel (selected): id выбранного уровня
- scroll: id первого уровня, который видно в боксе списка уровней.
- hit: список хитбоксов кнопок и опции
- hit_items: список хитбоксов уровней

### Components

```python
def _button(
    	self,
     	rectangle: Coord, # кортеж с координатами и размерами
      	label: str, # текст внутри кнопки
        props: BtnTypes = "default" # тип кнопки
    )
```

- Функция создает кнопку по переданным координатам и размерам. Также вид кнопки (цвета фона и рамки) зависят от переданго props.

```python
def _checkbox(
	self,
	rectangle, # кортеж с координатами и размерами
	checked: bool # состояние активации опции
)
```

1. как и _button функция создает компонент "option"
2. также, если checked является true, в option появляется зеленая галочка

### Event Handler

```python
def handle_event(
	self,
	event, # событие
	event_type # тип события
)
```

Нажатия клавиш:

`Space` | `Return` - **Начать игру**
`q` | `Q` | `Esc`  - **Выход**
`Up` -    **вверх на 1 селекцию**
`Down` -  **вниз на 1 селекцию**
`Next` -  **вверх на 5 селекции**
`Prior` - **вниз на 5 селекции**

Нажатия на элементы меню

1. сначало ***handle_event*** проверяет пришелся ли клик на хитбоксы селекции (уровней).

2. Далее он проверяет хитбоксы кнопок:
	- кнопка "Play": функция возвращает состояния опции, выбранный уровень и action "start"

	- кнопка "Exit": возвращает action "quit"

3. После метод проверяеи хитбоксы опции. Если опция нажата, то ее булево состояние меняется на противоположное и, если состояние True, внутри опции появляется галочка.

### Helpers

```python
def _has_selection(self)
```

- метод проверяет, не выходит ли id выбранного уровня за диапозон

<br>

```python
def _toggle_option(self, key)
```

- метод меняет состояние опции, чей ключ передается в параметрах, на противоположное

<br>

```python
def _move_sel(self, shift)
```

- метод сдвигает id выбранного уровня на shift раз

- ```max(0, min(len(s.levels) - 1, s.sel + shift))``` - данная строчка предназначена для возвращения id выбранного уровня в диапозон в случае, если он за него выходит после сдвига.

<br>

```python
def _ensure_sel_visible(seld)
```

- метод выделяет выбранный уровень синим прямоугольником
- метод регулирует показ уровней в боксе листа

```python
s.scroll = max(0, min(s.scroll, max(0, len(s.levels) - visible)))
```

- данная строчка метода `_ensure_sel_visible()` предназначена для возвращения scroll в диапозон в случае, если он за него выходит после сдвига.

```python
max(0, len(s.levels) - visible)
```

- количество уровней, которые не поместились в бокс листа уровней.



## Game View

### Attributes

```python
def _grid_to_pixel(self, row, col)
```

- перевод координат клетки по матрице в координаты по пикселям

<br>

```python
def _pixel_to_grid(self, x, y)
```

- перевод координат клетки по пикселям в координаты по матрице

<br>

```python
def _grid_center(self, row, col)
```

- метод возвращает координаты центра клетки по пикселям

<br>

### Event Handler

#### Нажатие клавиш

1. в случае окончания игровой сессии:
- `Return` | `Space` | `r` | `R` | `Space` : рестарт игры
- `Esc` : назад в меню

2. во время игры:
- `Space` : сделать ход
- `r` | `R` : рестарт игры
- `Esc` : назад в меню

#### Левый клик мишки

1. С помощью функции `abscisse` и `ordonnee` мы получаем координаты
2. Их мы конвертируем через `_pixel_to_grid` в координаты по матрице.
3. Если координаты не выходят за диапозон, то далее мы передаем конвертированные координаты в метод `rotate_cell` для переворота клетки на 90 градусов.


