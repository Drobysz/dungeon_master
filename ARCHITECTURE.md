# Wall is You - Documentation

## Content

- ### [Entities](#Entities)
- ### [Game field class (Dungeon)](#Game-field-class-(Dungeon))
- ### [Level parser method](#Level-parser-method)
- ### [Game Controller](#Game-Controller)
- ### [Menu (app.py)](#Menu-(app.py))
**Layout and event handlers related models**
- ### [Menu View](#Menu-View)
- ### [Game View](#Game-View)


## Entities

### Cell

#### Description
Класс Cell представляет из себя из себя клетку, где у каждой стороны есть состояние, отображающие наличие коридора (True - присутствует; False - отсутствует).

#### Attributes
Аттрибуты представляют из себя 4 состояния стены.

#### Methodes
- rotate(self):
	метод возвращает экземпляр класса Cell со сдвинутыми по часовой
	состояниями стены

- has_dir(self, directory):
	метод проверяет наличие коридора в указанном направлении,
	обращаясь к словарю с состаяниями стены по ключю переданного направления



### Dragon and Hero
Классы Dragon и Hero в качестве аттрибутов имеют позицию и уровень.
> [!IMPORTANT]
>На данном этапе разработки они используются в качестве типов с помощью
декоратора @dataclass.



## Game field class (Dungeon)

### Description
Данный класс представляет из себя матрицу экземпляров Cell

### Attributes
В качестве аттрибутов класс распалагает вышеупомянутой матрицей,
ее вычисляемыми шириной и высотой.

> [!Warning]
> ширина и высота в следующей версии будут присваиваться
> в магическом методе __init__

### Methodes

- in_bound(self, row, column):
	метод проверяет не выходят ли координаты за диапозон матрицы

- get_cell(self, row, column):
	метод по координатам возвращает нужный экземпляр,
	если координаты не выходят за рамки матрицы

- rotate_cell(self, row, column):
	метод переварачивает клетку по координатам

- neighbors(neighbors):
1. метод проходиться циклом по словарю DIRECTIONS через метод items() со значениями отступов для перемещения на соседнюю клетку по четырем направлениям, чьи названия используются в качестве ключей

2. Координаты соседней клетки = текущие + отступы

3. В случае, если координаты соседней клетки не выходят за границы (метод in_bounds()), то через yield они и их направление возвращаются кортежем.

- are_connected(
	self,
	row, column,
	n_row, n_column (neighbor cell coordinates)
):
	метод проверяет, связаны ли соседние клетки коридорами

1. сначала мы получаем значения отступов (таких же как в DIRECTIONS)
	shifted_row = n_row - row
	shifted_col = n_col - col

2. далее мы опять тем же методом проходимся по DIRECTIONS
3. каждую итерацию проверяем, не раны ли отступы по рядам и столбцам
	отступам по направлению
4. если равны, то проверяем не выходят ли клетки за рамки
5. получаем по координатам экземпляры Cell и проверяем, есть ли коридоры у противоположных направлении этих клеток.



## Level parser method

**load_levels(path):**
метод, который парсит json файлы с уровнями

load_levels парсит "grid", создает матрицу экземпляров Cell, на основе,
которой создает экземпляр Dungeon (game field class).

также load_levels создает объекты:
- hero (c уровнем и координатами);
- dragons (лист драконов со свойствами как у героя)

все созданные объекты (включая dungeon) метод возвращает кортежем



## Game Controller

### Description
Данный класс содержит сотстояния игры и entities, а также функционал игры.

### Attributes
- entities: dragons, hero
- game_over: состояние окончании игры
- options: словарь с опциями, выбранными в меню
- game_result: результат игры
- last_path: последний просчитанный путь героя

### Methodes

- _load_level(self):
	внутренний метод, задающий начальные состояния и получающий значения entities из одноименного парсера load_levels()

- reset(self):
	метод для сброса состоянии к дефолтным значениям, чтобы начать игры сначала. Для этого метод вызывает _load_level() внутри себя.

- is_over(self):
	метод передает состояние game_over;

> [!Warning]
> метод **is_over** будет удален в следующей версии
> из-за ненадобности

```python
def rotate_cell(self, row, col)
```
- вызывает метод класса Dungeon rotate_cell()

<br>

```python
def _compute_intention_path(self, max_steps)
```
- метод предназначен для выстраивания следующего пути/хода.

[^1]: сначала создаются переменные с координатами героя из hero["position"];
[^2]: цикл while с прибавлением steps += 1 до max_steps или break;
[^3]: обнуление next_pos;
[^4]: метод проходиться циклом по соседним клеткам, полученным через метод neighbors класса Dungeon;
[^5]: если клетка равна предыдущей (переменная "previous), пропускаем ее
[^6]: через метод are_connected класса Dungeon проверям наличие общих коридоров клеток;
[^7]: если они есть, то присваиваем координаты в next_pos, далее идет break;
[^8]: если после цикла next_pos остается None, то цикл while останавливается и возвращается текущий лист "path";
[^9]: переменной "previous" присваиватся текущие координаты и в "path" добавляется next_pos, к steps добавляется 1 шаг и цикл повторяется пока next_pos не станет None (то есть цткл дойдет до тупика).

- end_turn(self, render): 
метод проходится по высчитанному пути и обрабатывает случаи встреч с врагами.

> [!Note]
> в качестве параметра передается метод render класса GameView ответственнго за верстку игровой сессии и обработки нажатии клавищ и кликов.

[^1]: метод высчитывает путь через _compute_intention_path() и получает level героя.
[^2]: далее циклом for он проходится по координатам пути
[^3]: задаются переменные для дракона
[^4]: также циклом for метод проходится по списку драконов и сверяет их координаты с текущими. если они равны, то мы вытаскиваем id дракона и его уровень.
[^5]: если уровень героя равен или выше, то дракон по id удаляется из списка и его уровень отходит герою, иначе игра окончена поражением героя (статус сессии становиться "lose").
[^6]: после окончания сдвига на клетку происходит перерисовка персонажа.
[^7]: после цикла проиходит проверка состояния сессии и количества драконов.если все драконы повержены, то сессии присваивается стату "win"



## Menu (app.py)

app.py - файл, отвечающий за переключение между меню и игровой сессией.

### States/Variables

[^1]: В начале функции main создается окно и задается его расштрение. Также создается объект menu, и создаются переменные под GameController и GameView.


[^2]: В app.py существует перемменная состоянии игры с одноименным названием state.

#### Обзор состоянии переменной state:

1. ***MENU*** - в этом сосстоянии происходит постоянный рендер меню и обработка нажатии на клавиши и кликов по кнопкам меню.
- Cобытия:
	- **start** (`Enter` или кнопка `Play`): создание экземпляров GameController и GameView + передача данных сессии (выбранных опции) в game controller
	- **quit** (`Esc` или кнопка `Exit`): выход из игры

2. ***Game*** - в этом состоянии проиходит рендер игрового поля и запуск обработчика событий игровой сессии.
- События:
	- **END_TURN** (`Space`): сделать ход
	- **RESTART** (shortcut `R`): начать игру заново
	- **TO_MENU** (`Esc`): назад в меню



# 